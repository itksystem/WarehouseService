const db = require('openfsm-database-connection-producer');
const common      = require('openfsm-common');  /* Библиотека с общими параметрами */
const SQL        = require('common-warehouse-service').SQL;
const MESSAGES        = require('common-warehouse-service').MESSAGES;
const logger          = require('openfsm-logger-handler');
const ClientProducerAMQP  =  require('openfsm-client-producer-amqp'); // ходим в почту через шину
const amqp = require('amqplib');
require('dotenv').config({ path: '.env-warehouse-service' });

const { 
  RABBITMQ_HOST, RABBITMQ_PORT, RABBITMQ_USER, RABBITMQ_PASSWORD,  
  RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE,
  RABBITMQ_WAREHOUSE_RESERVATION_QUEUE, RABBITMQ_WAREHOUSE_DECLINE_QUEUE , RABBITMQ_ORDER_STATUS_QUEUE } = process.env;
  
const login = RABBITMQ_USER || 'guest';
const pwd = RABBITMQ_PASSWORD || 'guest';
const WAREHOUSE_RESERVATION_QUEUE = RABBITMQ_WAREHOUSE_RESERVATION_QUEUE || 'WAREHOUSE_RESERVATION';
const WAREHOUSE_DECLINE_QUEUE = RABBITMQ_WAREHOUSE_DECLINE_QUEUE || 'WAREHOUSE_DECLINE';
const ORDER_STATUS_QUEUE =  RABBITMQ_ORDER_STATUS_QUEUE || 'ORDER_STATUS';
const PAYMENT_ACCOUNT_CREATE_QUEUE =  RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE || `PAYMENT_ACCOUNT_CREATE`;
const host = RABBITMQ_HOST || 'rabbitmq-service';
const port = RABBITMQ_PORT || '5672';


 /* Получить параметры продукта зарегистрированного на складе  */
 exports.findProductById = async (productId) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCT_BY_PRODUCT_ID, [productId], (err, result) => {              
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });   
  return  result != undefined ? result?.rows[0]: null
};

exports.findProductsByCategories = async (brands = [], categories = [], page=1, limit=10, search = null, minPrice = null, maxPrice = null) => {
  console.log(brands, categories, page, limit, search )
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCTS_BY_CATEGORY_ID2, [
          page, limit, search, 
          categories?.length > 0 ? categories : null, 
          brands?.length > 0 ? brands : null,
           minPrice, 
           maxPrice
      ], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result != undefined ? result.rows: []
};

exports.findProductsByCategoriesByLike = async (brands = [], categories = [], page=1, limit=10, search = null, minPrice = null, maxPrice = null) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCTS_BY_CATEGORY_LIKE, [page, limit, search, minPrice, maxPrice], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result != undefined ? result.rows: null
};

exports.findMediaByProductId = async (productId) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_MEDIAS_BY_PRODUCT_ID, [productId], (err, result) => {        
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result != undefined ? result.rows: null
};

// зарезервировать товар 
exports.productReservation = async (productId, count) => {
  if(!productId && !count) return false     
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_RESERVE_ITEM, [count, count, productId, count], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result ? true : false;
}

// отмена резервирования товара
exports.productReleaseReservation = async (productId, count) => {
  if(!productId && !count) return false
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_RELEASE_ITEM, [count, count, productId, count], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result ? true : false;
}

exports.getBasketMedia = async (productId=null) => {
  if(!productId ) return false
   const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_MAIN_MEDIA_BY_PRODUCT_ID, [productId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  return result?.rows || null
}


// 23.11.2024
// Получить доступность всех продуктов в корзине 
exports.getBasketProductsAvailability = async (basketId) => {
   if(!basketId ) return false;
   const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_BASKET_PRODUCTS_AVAILIABILITY, [basketId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  return result.rows;  
}


exports.getProductCategories = async () => {  
  const result = await new Promise((resolve, reject) => {
   db.query(SQL.PRODUCT.SQL_GET_PRODUCT_CATEGORIES, [], (err, result) => {
     if (err) {
       logger.error(err);
       return reject(err);
     }
     resolve(result || null); // Предполагается, что поле isConfirmed
   });
 });  
 return result.rows;  
}


exports.getSearchQueries = async (query = null) => {  
  if(!query) return null;
  const result = await new Promise((resolve, reject) => {
   db.query(SQL.SEARCH_QUERIES.SQL_GET_SEARCH_QUERIES, [query], (err, result) => {
     if (err) {
       logger.error(err);
       return reject(err);
     }
     resolve(result || null); // Предполагается, что поле isConfirmed
   });
 });  
 return result.rows;  
}


exports.getProductBrands = async () => {  
  const result = await new Promise((resolve, reject) => {
   db.query(SQL.PRODUCT.SQL_GET_PRODUCT_BRANDS, [], (err, result) => {
     if (err) {
       logger.error(err);
       return reject(err);
     }
     resolve(result || null); // Предполагается, что поле isConfirmed
   });
 });  
 return result.rows;  
}

// *********************** Подключение к RabbitMQ и прослушивание очереди ******************************

async function startWarehouseReservationConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });    

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
             console.log(order);
             if(order) 
                await startWarehouseReservationProducer(order);
              channel.ack(msg); // Подтверждение обработки сообщения
          }
      });
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

async function startWarehouseDeclineConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
            console.log(order);
             if(order)             
               await startWarehouseDeclineProducer(JSON.parse(msg.content.toString()));
               channel.ack(msg); // Подтверждение обработки сообщения                                     
          }
      });      
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

// Продьюсер производящий резервирование товара
async function startWarehouseReservationProducer(msg){
  try {   
    const _items = await Promise.all( 
      msg.order.items.map(async (item) => {
        try { // перебираем товары в заказеа и резервируем их
          productId =item.productId;
          quantity =item.quantity;
          await exports.productReservation(productId, quantity);      
        } catch (err) { 
          console.error(`startWarehouseReservationProducer. Ошибка при резервировании товара ${err}`);          
        }
        return item;
      })
    );   
    await  reservedStatusMessageSend(msg);    
  } catch (error) {
    console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
 }
}

async function reservedStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: true, processStatus : 'RESERVED',  order: msg.order })  
    } catch (error) {
      console.log(`reservedStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}

async function declineStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: false, processStatus : 'DECLINE',  order: msg.order })  
    } catch (error) {
      console.log(`declineStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}


// Продьюсер производящий откат резщервирование товара
async function startWarehouseDeclineProducer(msg){
    try {   
      const _items = await Promise.all( 
        msg.order.items.map(async (item) => {
          try { // перебираем товары в заказе и снимаем резервирование их
            await exports.productReleaseReservation(item.productId, item.quantity);
          } catch (err) { 
            console.error(`startWarehouseDeclineProducer. Ошибка при отмене резервировании товара ${err}`);          
          }
          return item;
        })        
      );  
      await  declineStatusMessageSend(msg);               
    } catch (error) {
      console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
   }
  }

//
// SQL_REGISTER_SEARCH_QUERIES
// регистрация поискового запроса
// Продюсер registerSearchQueriesProducer
const  QUEUE_SQL_REGISTER_SEARCH_QUERIES = "REGISTER_SEARCH_QUERIES";
exports.registerSearchQueriesProducer = (msg) => { // 
  try {
     let rabbitClient = new ClientProducerAMQP();
      rabbitClient.sendMessage(QUEUE_SQL_REGISTER_SEARCH_QUERIES, msg)  
    } catch (error) {
      console.log(`declineStatusMessageSend. Ошибка ${error}`);
  }   
}

// Консьюмер registerSearchQueriesConsumer
async function registerSearchQueriesConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });
      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let o = JSON.parse(msg.content.toString())
             console.log(o);
             if (o && typeof o === 'object') {
              const searchText = o.text?.trim();
              if (searchText) {
                try {
                  db.query(SQL.SEARCH_QUERIES.SQL_REGISTER_SEARCH_QUERIES, [searchText]);
                } catch (error) {
                  console.error('Error registering search query:', error);
                  // Можно добавить дополнительную обработку ошибки
                }
              }
            }
           channel.ack(msg); // Подтверждение обработки сообщения
          }
      });
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}




/* Запуск консьюмеров */
 startWarehouseReservationConsumer(WAREHOUSE_RESERVATION_QUEUE);
 startWarehouseDeclineConsumer(WAREHOUSE_DECLINE_QUEUE);
 registerSearchQueriesConsumer(QUEUE_SQL_REGISTER_SEARCH_QUERIES);

 
 