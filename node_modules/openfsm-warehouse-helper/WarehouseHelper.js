const db = require('openfsm-database-connection-producer');
const common      = require('openfsm-common');  /* Библиотека с общими параметрами */
const SQL        = require('common-warehouse-service').SQL;
const MESSAGES        = require('common-warehouse-service').MESSAGES;
const logger          = require('openfsm-logger-handler');
const ClientProducerAMQP  =  require('openfsm-client-producer-amqp'); // ходим в почту через шину
require('dotenv').config();
const amqp = require('amqplib');

const { 
  RABBITMQ_HOST, RABBITMQ_PORT, RABBITMQ_USER, RABBITMQ_PASSWORD,  
  RABBITMQ_WAREHOUSE_RESERVATION_QUEUE, RABBITMQ_WAREHOUSE_DECLINE_QUEUE , RABBITMQ_ORDER_STATUS_QUEUE } = process.env;
  
const login = RABBITMQ_USER || 'guest';
const pwd = RABBITMQ_PASSWORD || 'guest';
const WAREHOUSE_RESERVATION_QUEUE = RABBITMQ_WAREHOUSE_RESERVATION_QUEUE || 'WAREHOUSE_RESERVATION';
const WAREHOUSE_DECLINE_QUEUE = RABBITMQ_WAREHOUSE_DECLINE_QUEUE || 'WAREHOUSE_DECLINE';
const ORDER_STATUS_QUEUE =  RABBITMQ_ORDER_STATUS_QUEUE || 'ORDER_STATUS'
const host = RABBITMQ_HOST || 'rabbitmq-service';
const port = RABBITMQ_PORT || '5672';


 /* Получить параметры продукта зарегистрированного на складе  */
 exports.findProductById = async (productId) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCT_BY_PRODUCT_ID, [productId], (err, result) => {              
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });   
  return  result != undefined ? result.rows: null
};

exports.findProductsByCategories = async (categories) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCTS_BY_CATEGORY_ID, [], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result != undefined ? result.rows: null
};

exports.findMediaByProductId = async (productId) => {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_MEDIAS_BY_PRODUCT_ID, [productId], (err, result) => {        
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result != undefined ? result.rows: null
};

// зарезервировать товар 
exports.productReservation = async (productId, count) => {
  if(!productId && !count) return false     
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_RESERVE_ITEM, [count, count, productId, count], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result ? true : false;
}

// отмена резервирования товара
exports.productReleaseReservation = async (productId, count) => {
  if(!productId && !count) return false
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_RELEASE_ITEM, [count, count, productId, count], (err, result) => {           
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result); // Предполагается, что поле isConfirmed
    });
  });  
  return  result ? true : false;
}

exports.getBasketMedia = async (productId) => {
  if(!productId ) return false
   const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_MAIN_MEDIA_BY_PRODUCT_ID, [productId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  return result?.rows[0] || null
}


// 23.11.2024
exports.productAvailability = async (basketId) => {
   if(!basketId ) return false;
   const result = await new Promise((resolve, reject) => {
    db.query(SQL.WAREHOUSE.SQL_GET_PRODUCT_AVAILIABILITY, [basketId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  return result.rows;  
}

// Подключение к RabbitMQ и прослушивание очереди
async function startWarehouseReservationConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });    

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
             console.log(order);
             if(order) 
                await startWarehouseReservationProducer(order);
              channel.ack(msg); // Подтверждение обработки сообщения
          }
      });
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

async function startWarehouseDeclineConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
            console.log(order);
             if(order)             
               await startWarehouseDeclineProducer(JSON.parse(msg.content.toString()));
               channel.ack(msg); // Подтверждение обработки сообщения                                     
          }
      });      
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

// Продьюсер производящий резервирование товара
async function startWarehouseReservationProducer(msg){
  try {   
    const _items = await Promise.all( 
      msg.order.items.map(async (item) => {
        try { // перебираем товары в заказеа и резервируем их
          productId =item.productId;
          quantity =item.quantity;
          await exports.productReservation(productId, quantity);      
        } catch (err) { 
          console.error(`startWarehouseReservationProducer. Ошибка при резервировании товара ${err}`);          
        }
        return item;
      })
    );   
    await  reservedStatusMessageSend(msg);    
  } catch (error) {
    console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
 }
}

async function reservedStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: true, processStatus : 'RESERVED',  order: msg.order })  
    } catch (error) {
      console.log(`reservedStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}

async function declineStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: false, processStatus : 'DECLINE',  order: msg.order })  
    } catch (error) {
      console.log(`declineStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}


// Продьюсер производящий откат резщервирование товара
async function startWarehouseDeclineProducer(msg){
    try {   
      const _items = await Promise.all( 
        msg.order.items.map(async (item) => {
          try { // перебираем товары в заказе и снимаем резервирование их
            await exports.productReleaseReservation(item.productId, item.quantity);
          } catch (err) { 
            console.error(`startWarehouseDeclineProducer. Ошибка при отмене резервировании товара ${err}`);          
          }
          return item;
        })        
      );  
      await  declineStatusMessageSend(msg);               
    } catch (error) {
      console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
   }
  }



/* Запуск консьюмеров */
 startWarehouseReservationConsumer(WAREHOUSE_RESERVATION_QUEUE);
 startWarehouseDeclineConsumer(WAREHOUSE_DECLINE_QUEUE);