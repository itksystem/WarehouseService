const db = require('openfsm-database-connection-producer');
const Transaction = require('openfsm-transaction-helper');
const common      = require('openfsm-common');  /* Библиотека с общими параметрами */
require('dotenv').config();
const ClientProducerAMQP  =  require('openfsm-client-producer-amqp'); // ходим в почту через шину
const amqp = require('amqplib');

const { 
  RABBITMQ_HOST, RABBITMQ_PORT, RABBITMQ_USER, RABBITMQ_PASSWORD,  
  RABBITMQ_WAREHOUSE_RESERVATION_QUEUE, RABBITMQ_WAREHOUSE_DECLINE_QUEUE , RABBITMQ_ORDER_STATUS_QUEUE } = process.env;
const login = RABBITMQ_USER || 'guest';
const pwd = RABBITMQ_PASSWORD || 'guest';
const WAREHOUSE_RESERVATION_QUEUE = RABBITMQ_WAREHOUSE_RESERVATION_QUEUE || 'WAREHOUSE_RESERVATION';
const WAREHOUSE_DECLINE_QUEUE = RABBITMQ_WAREHOUSE_DECLINE_QUEUE || 'WAREHOUSE_DECLINE';
const ORDER_STATUS_QUEUE =  RABBITMQ_ORDER_STATUS_QUEUE || 'ORDER_STATUS'
const host = RABBITMQ_HOST || 'rabbitmq-service';
const port = RABBITMQ_PORT || '5672';


 /* Получить параметры продукта зарегистрированного на складе  */
 exports.findProductById = (productId) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL_GET_PRODUCT_BY_PRODUCT_ID, [productId], (err, result) => {           
      (err)
      ? reject(err)
      : resolve((result[0] != undefined ? result[0]: null));
    });
  });
};

exports.findProductsByCategories = (categories) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL_GET_PRODUCTS_BY_CATEGORY_ID, [categories], (err, result) => {           
      (err)
      ? reject(err)
      : resolve((result != undefined ? result: null));
    });
  });
};

exports.findMediaByProductId = (productId) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL_GET_MEDIAS_BY_PRODUCT_ID, [productId], (err, result) => {           
      (err)
      ? reject(err)
      : resolve((result != undefined ? result: null));
    });
  });
};

// зарезервировать товар 
exports.productReservation = (productId, count) => {
  if(!productId && !count) return false     
  return new Promise((resolve, reject) => {    
    db.query(common.SQL_RESERVE_ITEM, [count, count, productId, count], (err, result) => {           
      (err)
      ? reject(false)
      : resolve(result.affectedRows > 0 ? true : false);
    });
  });
}

// отмена резервирования товара
exports.productReleaseReservation = (productId, count) => {
  if(!productId && !count) return false
  return new Promise((resolve, reject) => {    
    db.query(common.SQL_RELEASE_ITEM, [count, count, productId, count], (err, result) => {           
      (err)
      ? reject(false)
      : resolve(result.affectedRows > 0 ? true : false);
    });
  });
}

exports.getBasketMedia = (productId) => {
  if(!productId ) return false
  return new Promise((resolve, reject) => {    
    let media = db.query(common.SQL_MAIN_MEDIA_BY_PRODUCT_ID, [productId], (err, result) => {           
      (err)
      ? reject(null)
      : resolve(result)
    });
  });
}


// 23.11.2024
exports.productAvailability = (basketId) => {
  if(!basketId ) return false;
  let sql = `
  SELECT 
    wbi.product_id AS product_id,    
    wbi.quantity AS items_in_basket,
    w.quantity AS items_in_warehouse,
    CASE 
        WHEN w.quantity >= wbi.quantity THEN 1 
        ELSE 0
    END AS availability
  FROM 
    warehouse_basket_item wbi
  JOIN 
    warehouse w ON wbi.product_id = w.product_id
  WHERE 
    wbi.basket_id = ? and wbi.order_id is null
  ORDER BY 
    wbi.product_id;
`
  return new Promise((resolve, reject) => {    
    db.query(sql, [basketId], (err, result) => {           
      (err)
      ? reject(null)
      : resolve(result ? result : null)    
      
    });
  });
}

// Подключение к RabbitMQ и прослушивание очереди
async function startWarehouseReservationConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });    

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
             console.log(order);
             if(order) 
                await startWarehouseReservationProducer(order);
              channel.ack(msg); // Подтверждение обработки сообщения
          }
      });
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

async function startWarehouseDeclineConsumer(queue){
  try {        
      console.log(`Ожидание сообщений в очереди ${queue}...`);
      const connection = await amqp.connect(`amqp://${login}:${pwd}@${host}:${port}`);
      const channel = await connection.createChannel();
      await channel.assertQueue(queue, { durable: true });

      channel.consume(queue, async (msg) => {
          if (msg !== null) {
            let order = JSON.parse(msg.content.toString())
            console.log(order);
             if(order)             
               await startWarehouseDeclineProducer(JSON.parse(msg.content.toString()));
               channel.ack(msg); // Подтверждение обработки сообщения                                     
          }
      });      
    } catch (error) {
      console.error(`Ошибка подключения к RabbitMQ: ${error}`);
  }
}

// Продьюсер производящий резервирование товара
async function startWarehouseReservationProducer(msg){
  try {   
    const _items = await Promise.all( 
      msg.order.items.map(async (item) => {
        try { // перебираем товары в заказеа и резервируем их
          productId =item.productId;
          quantity =item.quantity;
          await exports.productReservation(productId, quantity);      
        } catch (err) { 
          console.error(`startWarehouseReservationProducer. Ошибка при резервировании товара ${err}`);          
        }
        return item;
      })
    );   
    await  reservedStatusMessageSend(msg);    
  } catch (error) {
    console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
 }
}

async function reservedStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: true, processStatus : 'RESERVED',  order: msg.order })  
    } catch (error) {
      console.log(`reservedStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}

async function declineStatusMessageSend(msg){ // поставить статус - зарезервировано
  try {
     let rabbitClient = new ClientProducerAMQP();
      await  rabbitClient.sendMessage(ORDER_STATUS_QUEUE, {status: false, processStatus : 'DECLINE',  order: msg.order })  
    } catch (error) {
      console.log(`declineStatusMessageSend. Ошибка ${error}`);
  } 
  return;
}


// Продьюсер производящий откат резщервирование товара
async function startWarehouseDeclineProducer(msg){
    try {   
      const _items = await Promise.all( 
        msg.order.items.map(async (item) => {
          try { // перебираем товары в заказе и снимаем резервирование их
            await exports.productReleaseReservation(item.productId, item.quantity);
          } catch (err) { 
            console.error(`startWarehouseDeclineProducer. Ошибка при отмене резервировании товара ${err}`);          
          }
          return item;
        })        
      );  
      await  declineStatusMessageSend(msg);               
    } catch (error) {
      console.error(`warehouseDeclineProducer. Ошибка: ${error}`);
   }
  }



/* Запуск консьюмеров */
 startWarehouseReservationConsumer(WAREHOUSE_RESERVATION_QUEUE);
 startWarehouseDeclineConsumer(WAREHOUSE_DECLINE_QUEUE);