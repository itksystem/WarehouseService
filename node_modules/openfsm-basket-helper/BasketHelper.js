// Модель товара в корзине
const db = require('openfsm-database-connection-producer');
const warehouseHelper = require('openfsm-warehouse-helper');
const BasketItemDto   = require('openfsm-basket-item-dto');
const MediaImageDto = require('openfsm-media-image-dto');
const SQL = require('common-warehouse-service').SQL;
const MESSAGES        = require('common-warehouse-service').MESSAGES;
const LANGUAGE = 'RU';
const logger = require('openfsm-logger-handler');
const amqp = require('amqplib');
require('dotenv').config({ path: '.env-warehouse-service' });

const { RABBITMQ_HOST, RABBITMQ_PORT, RABBITMQ_USER, RABBITMQ_PASSWORD, RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE } = process.env;    
const login = RABBITMQ_USER || 'guest';
const pwd = RABBITMQ_PASSWORD || 'guest';
const host = RABBITMQ_HOST || 'rabbitmq-service';
const port = RABBITMQ_PORT || '5672';
const PAYMENT_ACCOUNT_CREATE_QUEUE =  RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE || `PAYMENT_ACCOUNT_CREATE`;


/* создаем корзину пользователя  */
async function createBasket(userId) {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(SQL.BASKET.SQL_CREATE_BASKET, [userId], (err, result) => {
        if (err) {
          logger.error("Ошибка при создании корзины для пользователя:", err); // Добавляем контекст к ошибке
          return reject(err); // Отклоняем промис с ошибкой
        }
        resolve(result || null); // Разрешаем промис с результатом запроса
      });
    });

    // Возвращаем ID корзины, если он существует, иначе возвращаем null
    return result?.rows?.[0]?.id ?? null;
  } catch (err) {
    // Логируем ошибку в случае неудачи и возвращаем null
    logger.error("Не удалось создать корзину пользователя:", err);
    return null;
  }
}


// Получить количество продуктов на складе
async function getWarehouseProductCount (productId) {
  if (!productId) return 0; // Если productId не передан, сразу возвращаем 0

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(SQL.WAREHOUSE.SQL_GET_PRODUCT_COUNT, [productId], (err, result) => {
        if (err) {
          logger.error("Ошибка при получении количества продукта:", err);
          return reject(err); // Отклоняем промис с ошибкой
        }
        resolve(result || null); // Разрешаем промис с результатом запроса
      });
    });

    // Возвращаем доступное количество товара, если оно есть, иначе возвращаем 0
    return result?.rows?.[0]?.available_quantity ?? 0;
  } catch (err) {
    // Логируем ошибку и возвращаем 0 в случае неудачи
    logger.error("Не удалось получить количество продукта на складе:", err);
    return 0;
  }
};


/* добавить в корзину товар */
async function addItemToBasket(userId, productId, quantity) {
  try {
    // Получаем ID корзины пользователя
    const basketId = await getBasketId(userId);
    // смотрим есть ли     
    const find = await new Promise((resolve, reject) => {
      db.query(SQL.BASKET.SQL_FIND_BASKET_ITEM_BY_PRODUCT_ID, [basketId, productId], (err, result) => {
        if (err) {
          logger.error("Ошибка в базе данных:", err); // Добавляем контекст к ошибке
          return reject(err); // Отклоняем промис с ошибкой
        }
        resolve(result); // Разрешаем промис с результатом запроса
      });
    });
   
    // Выполняем запрос к базе данных для обновления количества товара в корзине
    const result = await new Promise((resolve, reject) => {
      db.query(
        ((find?.rows?.length === 0)
          ? SQL.BASKET.SQL_INSERT_BASKET_QUANTITY_ITEM_BY_PRODUCT_ID  // добавляем
          : SQL.BASKET.SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID),  // обнавляем
        [quantity, basketId, productId], (err, result) => {
        if (err) {
          logger.error("Ошибка в базе данных:", err); // Добавляем контекст к ошибке
          return reject(err); // Отклоняем промис с ошибкой
        }
        resolve(result); // Разрешаем промис с результатом запроса
      });
    });

    // Возвращаем обновлённое количество, если оно есть, иначе возвращаем исходное количество
    return result?.rows?.[0]?.quantity ?? quantity;
  } catch (err) {
    // Логируем ошибку и возвращаем исходное количество товара в случае неудачи
    logger.error("Не удалось добавить товар в корзину:", err);
    return err;
  }
}



/* Получить количество заказанного товара одной позиции в корзине */
async function getProductCountInBasket(userId, productId) {
  try {
    // Получаем basketId для пользователя
    const basketId = await getBasketId(userId);

    // Выполняем запрос в базу данных
    const result = await new Promise((resolve, reject) => {
      db.query(SQL.BASKET.GET_PRODUCT_COUNT, [basketId, productId], (err, result) => {
        if (err) {
          logger.error(`Error fetching product count for productId ${productId}: ${err.message}`);
          return reject(err);
        }
        resolve(result || null); // Возвращаем результат или null, если его нет
      });
    });

    // Проверяем, есть ли данные в результате запроса
    return result?.rows[0]?.quantity ?? 0; // Возвращаем количество товара или 0, если данных нет

  } catch (error) {
    logger.error(`Error in getProductCountInBasket: ${error.message}`);
    return 0;  // Возвращаем 0 в случае ошибки
  }
}


/* Удалить запись из корзины */
async function removeItemFromBasket(userId, productId, quantity) {
  const basketId = await getBasketId(userId);
  try {
    // Выполняем запрос на изменение количества товара в корзине
    const result = await db.query(SQL.BASKET.SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID, [-quantity, basketId, productId]);
    
    // Возвращаем обновленное количество товара, если оно есть
    return result?.rows[0]?.quantity ?? 0;  
  } catch (err) {
    logger.error(`Error removing item from basket: ${err.message}`);
    return 0;  // Возвращаем 0 в случае ошибки
  }
}


/* Удалить всю товарную позицию  из корзины */
async function removeProductFromBasket(userId, productId, quantity) {
  try {
    const basketId = await getBasketId(userId);

    // Запрашиваем товар в корзине
    const existingItems = await db.query(SQL.BASKET.SQL_FIND_BASKET_ITEM_BY_PRODUCT_ID, [basketId, productId]);

    if (!existingItems.rows.length) return 0; // Если товара нет в корзине, просто возвращаем 0

    const currentQuantity = existingItems.rows[0].quantity;
    const newQuantity = Math.max(0, currentQuantity - quantity); // Не допускаем отрицательное количество  

    // Обновляем количество товара в корзине
    await db.query(SQL.BASKET.SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID, [-quantity, basketId, productId]);

    return newQuantity;  
  } catch (error) {
    console.error(`Ошибка при удалении товара из корзины: ${error.message}`);
    throw new Error("Ошибка при удалении товара");
  }
}


/* Получить состояние корзины */
async function getBasket(userId) {
  try {
    const basketId = await getBasketId(userId);
    
    if (!basketId) return []; // Если корзина не найдена, возвращаем пустой массив

    const { rows: items } = await db.query(SQL.BASKET.SQL_GET_BASKET_ITEMS, [basketId]);
   // Обрабатываем товары и добавляем медиа файлы
      const updatedItems = await Promise.all(
          items.map(async (item) => {
              try {
                  let media = await warehouseHelper.getBasketMedia(item.product_id);                                    
                  item.media_files = media.map(_media => _media ? new MediaImageDto(_media) : null); // Исправлено: проверка _media
                  return item; // Возвращаем обновленный item
              } catch (mediaError) {
                  console.error(`Ошибка при получении медиа для product_id ${item.product_id}: ${mediaError.message}`);
                  item.media_files = []; // Инициализируем mediaFiles пустым массивом
                  return item; // Возвращаем item с пустым mediaFiles
              }
          })
      );
    return updatedItems
  } catch (error) {
    console.error(`Ошибка при получении корзины: ${error.message}`);
    throw new Error("Не удалось получить корзину");
  }
}

/*  Получить идентификатор корзины */
async function getBasketId(userId) {    
  try {
    const { rows } = await db.query(SQL.BASKET.SQL_FIND_BASKET_BY_USER_ID, [userId]);

    if (rows.length > 0) {
      return rows[0].id;
    }

    // Корзина не найдена — создаём новую
    return await createBasket(userId);
  } catch (error) {
    logger.error(`Ошибка в getBasketId: ${error.message}`);
    throw error; // Пробрасываем ошибку дальше
  }
}


/* Закрыть корзины и товарам присвоить orderId */
async function orderCreate(orderId = null, basketId = null ) {
  try {
    // Выполняем запрос на создание заказа
    if(!orderId || !basketId) throw(`warehouse.orderCreate orderId ${orderId} basketId ${basketId}`);
    await db.query(SQL.BASKET.SQL_ORDER_CREATE, [orderId, basketId]);
    return true; // Возвращаем успех
  } catch (err) {
    logger.error(err); // Логируем ошибку
    return false; // Возвращаем неудачу в случае ошибки
  }
}

async function orderDecline(orderId = null, basketId = null ) {
  try {
    // Выполняем запрос на создание заказа
    if(!orderId || !basketId) throw(`warehouse.orderDecline orderId ${orderId} basketId ${basketId}`);    
    await db.query(SQL.BASKET.ORDER_DECLINE, [orderId, basketId]);
    return true; // Возвращаем успех
  } catch (err) {
    logger.error(err); // Логируем ошибку
    return false; // Возвращаем неудачу в случае ошибки
  }
}

/* Получить состав заказа в корзине */
async function getBasketOrder(orderId = null, basketId = null) {
  try {    
      if (!orderId || !basketId) {
          throw new Error(`warehouse.getBasketOrder: orderId ${orderId}, basketId ${basketId}`);
      }

      // Получаем товары в корзине
      const { rows: items } = await db.query(SQL.BASKET.SQL_GET_BASKET_ORDER_ITEMS, [orderId, basketId]);

      // Обрабатываем товары и добавляем медиа файлы
      const updatedItems = await Promise.all(
          items.map(async (item) => {
              try {
                  let media = await warehouseHelper.getBasketMedia(item.product_id);                  
                  item.media_files = media.map(_media => _media ? new MediaImageDto(_media) : null); // Исправлено: проверка _media
                  return item; // Возвращаем обновленный item
              } catch (mediaError) {
                  console.error(`Ошибка при получении медиа для product_id ${item.product_id}: ${mediaError.message}`);
                  item.media_files = []; // Инициализируем mediaFiles пустым массивом
                  return item; // Возвращаем item с пустым mediaFiles
              }
          })
      );
      console.log(updatedItems);
      return updatedItems;
  } catch (error) {
      console.error(`Ошибка в getBasketOrder: ${error.message}`);
      return [];
  }
}


// Получить детали заказа
async function getOrderDetails(basketId, orderId) {
  try {
    // Выполняем запрос на получение деталей заказа
    const { rows: items } = await db.query(  SQL.BASKET.SQL_GET_ORDER_DETAILS,     
      [basketId, orderId]
    );
    return items; 
  } catch (err) {
    logger.error(`Ошибка при получении деталей заказа: ${err.message}`);
    throw err;  // Пробрасываем ошибку дальше, если нужно
  }
}

// удалить продукт из корзины
async function productBasketRemove(userId, productId) {
  try {
    const basketId = await getBasketId(userId);
    // Выполняем запрос на удаление товара из корзины
    await db.query(SQL.BASKET.SQL_UPDATE_BASKET_REMOVE_ITEM_BY_PRODUCT_ID, [basketId, productId]);
    return true;  // Возвращаем true, если товар был успешно удален
  } catch (err) {
    logger.error(`${MESSAGES[LANGUAGE].ERROR_REMOVING_PRODUCT_FROM_BASKET} productId ${productId}  => ${err}`);
    return false;  // Возвращаем false в случае ошибки
  }
}

// удалить продукт из заказа
async function removeOrderItem(basketId, productId, orderId) {
  try {    
    // Выполняем запрос на удаление товара из корзины
    await db.query(SQL.BASKET.SQL_REMOVE_ITEM_BY_PRODUCT_ID_FROM_ORDER, [basketId, productId, orderId]);
    return true;  // Возвращаем true, если товар был успешно удален
  } catch (err) {
    logger.error(`${MESSAGES[LANGUAGE].SQL_REMOVE_ITEM_BY_PRODUCT_ID_FROM_ORDER} productId ${productId}  => ${err}`);
    return false;  // Возвращаем false в случае ошибки
  }
}




  module.exports = { addItemToBasket, removeItemFromBasket, getBasket, orderCreate, getBasketOrder, 
    getBasketId, getProductCountInBasket, getOrderDetails, productBasketRemove, getWarehouseProductCount,
     orderDecline, removeOrderItem};