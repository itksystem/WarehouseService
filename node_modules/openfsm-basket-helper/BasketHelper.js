// Модель товара в корзине
const db = require('openfsm-database-connection-producer');
const { v4: uuidv4 } = require('uuid'); 
const common       = require('openfsm-common');  /* Библиотека с общими параметрами */
const warehouseHelper = require('openfsm-warehouse-helper');
const MediaImageDto = require('openfsm-media-image-dto');
const SQL        = require('common-warehouse-service').SQL;
const MESSAGES        = require('common-warehouse-service').MESSAGES;
const LANGUAGE = 'RU';
const WarehouseError  = require('openfsm-custom-error');
const logger          = require('openfsm-logger-handler');


require('dotenv').config({ path: '.env-warehouse-service' });


/* создаем корзину пользователя  */
async function createBasket(userId) {
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_CREATE_BASKET, [userId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  return result.rows[0].id;
}

/* добавить в корзину товар */
async function addItemToBasket(userId, productId, quantity) {
  const basketId = await getBasketId(userId);  
  try {
  const item = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_UPSERT_BASKET_QUANTITY, [quantity, basketId, productId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
     });
    });    
    return item?.rows[0].quantity;  
   } catch (err) {
      logger.error(err);
      return quantity;    
  }   
}

/* Получить количество заказанного товара одной позиции в корзине */
async function getProductCountInBasket(userId, productId) {
  try {
      const basketId = await getBasketId(userId);  
      const result = await new Promise((resolve, reject) => {
      db.query(
        SQL.BASKET.GET_PRODUCT_COUNT, [basketId, productId], (err, result) => {
        if (err) {
           logger.error(err);
           return reject(err);
         }
         resolve(result|| null); 
       });
      });  
      return result?.rows[0].quantity || 0
    } catch (error) {
      logger.error(error);
   return 0;    
  }
}

/* Удалить запись из корзины */
async function removeItemFromBasket(userId, productId, quantity) {  
  const basketId = await getBasketId(userId);  
  try {
  const item = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID, [-quantity, basketId, productId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
     });
    });    
    return item?.rows[0]?.quantity || 0;  
   } catch (err) {
      logger.error(err);
      return quantity;    
  }   
}



/* Удалить всю товарную позицию  из корзины */
async function removeProductFromBasket(userId, productId, quantity) {
  const basketId = await getBasketId(userId);
  const [existingItem] = await db.promise().query( SQL.BASKET.SQL_FIND_BASKET_ITEM_BY_PRODUCT_ID,  [basketId, productId]);
  try {
    if (existingItem.rows.length > 0) {
      await db.promise().query( SQL.BASKET.SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID, [ -quantity, basketId, productId] );
      return existingItem.rows[0].quantity - quantity;
    } else  return 0;     
  } catch (error) {
 return 0;    
}
}


/* Получить состояние корзины */
async function getBasket(userId) {
  const basketId = await getBasketId(userId);

  const items = await new Promise((resolve, reject) => {    
    db.query(SQL.BASKET.SQL_GET_BASKET_ITEMS, [basketId], (err, result) => {           
      (err)
        ? reject(err)
        : resolve(result?.rows || []);
    });
  });

  await Promise.all(
    items.map(async (item) => {
      try { 
        const media = await warehouseHelper.getBasketMedia(item?.product_id);
        item.media_files = media
          ? [new MediaImageDto(media)] 
          : [];
      } catch (mediaError) {
        console.error(`Error fetching media for product_id ${item.product_id}: ${mediaError.message}`);
        item.media_files = []; 
      }    
    })
  );

  return items; 
}



async function getBasketId(userId) {    
  const basket = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_FIND_BASKET_BY_USER_ID, [userId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(err);
      }
      resolve(result || null); // Предполагается, что поле isConfirmed
    });
  });  
  let basketId =  basket?.rows ? basket?.rows[0].id : await createBasket(userId);     
  return basketId;
}

/* Закрыть корзины и товарам присвоить orderId */
async function orderCreate(basketId, orderId) {
    let result = await new Promise((resolve, reject) => {
      db.query(SQL.BASKET.SQL_ORDER_CREATE, [orderId, basketId], (err, result) => {
        if (err) {
          logger.error(err);
          return reject(false);
        }
        resolve(true); 
      });
    });           
  return result; 
}

/* Получить состав заказа в корзине */
async function getBasketOrder(userId, orderId) {
  const basketId = await getBasketId(userId);  
  let items = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_GET_BASKET_ORDER_ITEMS, [orderId, basketId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(false);
      }
      resolve(result); 
    });
  });           
  await Promise.all(items.rows.map(async (item) => {
    try { 
      const media = await warehouseHelper.getBasketMedia(item.product_id);
      item.media_files = media.length > 0 ? [ new MediaImageDto(media[0]) ] : [];
    } catch (mediaError) {
      console.error(`Error fetching media for product_id ${item.product_id}: ${mediaError.message}`);
      item.media_files = []; 
    }    
  }));
  return items.rows; 
}

// getOrderDetails
async function  getOrderDetails(basketId, orderId) {
  /*const [items] = await db.promise().query(`SELECT * FROM warehouse_basket_item WHERE basket_id = ? and order_id = ? `, [basketId, orderId]);  
  return items.length > 0 ? items : [];
  */
  const [items] = await new Promise((resolve, reject) => {
    db.query(`SELECT * FROM warehouse_basket_item WHERE basket_id = ? and order_id = ? `, [basketId, orderId], (err, result) => {
      if (err) {
        logger.error(err);
        return reject(false);
      }
      resolve(result); 
    });
  });           
  return items.rows; 
}

async function productBasketRemove(userId, productId) {
  /*  try {   
  
   const basketId = await getBasketId(userId);
   const result = await db.promise().query(SQL.BASKET.SQL_UPDATE_BASKET_REMOVE_ITEM_BY_PRODUCT_ID, [ basketId, productId]);  
   if(!result) throw new WarehouseError(500, MESSAGES[LANGUAGE].ERROR_REMOVING_PRODUCT_FROM_BASKET ); 
     } catch (err) {
     logger.error(`${MESSAGES[LANGUAGE].ERROR_REMOVING_PRODUCT_FROM_BASKET} productId ${productId}  => ${err}`);
     return false; 
   };
  return true; 
  */
  
  const basketId = await getBasketId(userId);
  const result = await new Promise((resolve, reject) => {
    db.query(SQL.BASKET.SQL_UPDATE_BASKET_REMOVE_ITEM_BY_PRODUCT_ID, [ basketId, productId], (err, result) => {
      if (err) {
        logger.error(`${MESSAGES[LANGUAGE].ERROR_REMOVING_PRODUCT_FROM_BASKET} productId ${productId}  => ${err}`);
        return reject(false);
      }
      resolve(result); 
    });
  });           
  return true; 
}


module.exports = { addItemToBasket, removeItemFromBasket, getBasket, orderCreate, getBasketOrder, getBasketId, getProductCountInBasket, getOrderDetails, productBasketRemove};