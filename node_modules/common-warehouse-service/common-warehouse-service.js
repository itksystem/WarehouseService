// Общая библиотека Warehouse

const { SQL_GET_PRODUCTS_BY_CATEGORY_ID } = require("openfsm-common");

/* SQL Queries */
const SQL = {
  PRODUCT : {    
    SQL_GET_PRODUCT_CATEGORIES : `
    select category_id as id, parent_id as "parentId", category_name as name 
    from pa_warehouse_service.warehouse_categories categories
    order by category_name asc
    `,
    SQL_GET_PRODUCT_BRANDS : `
    select 
      brand_id as id, 
      null as "parentId", 
      brand_name as name 
    from pa_warehouse_service.warehouse_brands brands
    order by brand_name asc
    `, 
    LOGOS :  // логоnullтипы
    `SELECT b.brand_name,l.size,l.svg_content FROM pa_warehouse_service.warehouse_brand_logos l
  JOIN pa_warehouse_service.warehouse_brands b ON l.brand_slug = b.brand_slug
WHERE  b.brand_slug = 'nike'
ORDER BY 
    CASE l.size
        WHEN '18x18' THEN 1
        WHEN '36x36' THEN 2
        WHEN '72x72' THEN 3
        WHEN '144x144' THEN 4
    END`},
  SEARCH_QUERIES : {  
    SQL_GET_SEARCH_QUERIES : `
    SELECT query_id AS "id", query_text AS "query" 
FROM pa_warehouse_service.warehouse_search_queries 
WHERE 1=1 
AND search_count > 3
AND (
    -- Если поисковый запрос NULL - игнорируем условия поиска
    $1::text IS NULL 
    OR
    (-- Преобразуем набор строк в массив и ищем совпадения в любом из элементов            
        $1::text = ANY(STRING_TO_ARRAY(query_text, ' '))
        OR
        to_tsvector('russian', COALESCE(query_text, '')) @@ to_tsquery('russian', COALESCE($1::text, ''))
        OR query_text ILIKE $1::text || '%'
    )
)
ORDER BY search_count DESC
LIMIT 10 OFFSET 0
`,
    // Для консьюмера автоматически формирующего поисковые слова, поправить текст
    SQL_AUTO_CREATE_SEARCH_WORDS : `
WITH analyzed_text AS (
  SELECT 
    'Уникальный набор накладок Zelda для стиков Nintendo Switch для контроллеров Joy-Con от Gadget Candy. Zelda -это серия экшн-адвентюрных игр в стиле эпического фентези, созданная известным игровым дизайнером Шигеру Миямото. Обеспечивают комфортный и легкий игровой опыт при использовании игровой консоли. Подчеркивают индивидуальный стиль и позволяют персонализировать внешний вид Вашего гаджета. Выполнены из качественного гипоаллергенного силикона. С ними пользователю будет удобнее контролировать действия во время игры, что помогает повысить шансы на победу и достичь наилучшего результата! В комплект входят 4 насадки на стики для приставки нинтендо свитч джой кон. В широком ассортименте нашего магазина также можно приобрести аксессуары для вашего устройства с принтом любимых персонажей. Такой набор может стать отличным подарком другу, девушке, любимому парню, мужу, жене, брату или сестре на День рождения, Новый год, 8 марта или 23 февраля. И в этом вам поможет команда Gadget Candy!
' AS full_text
),
extracted_keywords AS (
  SELECT 
    unnest(extract_product_keywords(full_text)) AS keyword
  FROM analyzed_text
  WHERE extract_product_keywords(full_text) IS NOT NULL
),
keyword_stats AS (
  SELECT 
    keyword,
    COUNT(*) AS term_frequency,
    CASE 
      WHEN keyword ~* 'zelda|nintendo|switch|joy-con' THEN 3  -- Высокий приоритет брендов
      WHEN keyword ~* '\y(накладк|стик|контроллер|аксессуар)' THEN 2  -- Средний приоритет компонентов
      ELSE 1  -- Низкий приоритет остальных терминов
    END AS priority
  FROM extracted_keywords
  GROUP BY keyword
)
SELECT 
  keyword AS query_text,
  term_frequency * priority AS search_count,  -- Взвешенное количество
  0 AS last_search_result,  -- Будет обновлено при реальном поиске
  CURRENT_TIMESTAMP AS created_at,
  CURRENT_TIMESTAMP AS updated_at
FROM keyword_stats
WHERE keyword IS NOT NULL
AND length(keyword) BETWEEN 3 AND 50  -- Валидация длины ключевого слова

    `,
    SQL_SEARCH_WORDS : `SELECT query_text as "query_text"
      FROM pa_warehouse_service.warehouse_search_queries 
      WHERE query_text ILIKE 'конф' || '%'
      ORDER BY search_count DESC
      LIMIT 5;
    `,
    SQL_REGISTER_SEARCH_QUERIES : `
     INSERT INTO pa_warehouse_service.warehouse_search_queries (
     query_text, 
     search_count, 
     last_searched_at,
     updated_at
     )
      VALUES (
      $1::text, 
      1,       
      CURRENT_TIMESTAMP,
      CURRENT_TIMESTAMP
      )
      ON CONFLICT (query_text) 
      DO UPDATE SET 
        search_count = warehouse_search_queries.search_count + 1,
        last_searched_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
      RETURNING *
    `
  },
  WAREHOUSE: {
    SQL_GET_MEDIAS_BY_PRODUCT_ID : "SELECT media_id, media_key, mime_type, size, is_default from pa_warehouse_service.warehouse_media_storage WHERE product_id = $1",
    SQL_MAIN_MEDIA_BY_PRODUCT_ID : "SELECT media_id, media_key, mime_type, size, is_default from pa_warehouse_service.warehouse_media_storage WHERE product_id = $1",
    SQL_RESERVE_ITEM : `UPDATE  pa_warehouse_service.warehouse SET reserved_quantity = reserved_quantity + $1,  quantity = quantity - $2  WHERE product_id = $3 AND quantity - reserved_quantity >= $4`,
    SQL_RELEASE_ITEM : `UPDATE  pa_warehouse_service.warehouse SET reserved_quantity = reserved_quantity - $1,  quantity = quantity + $2  WHERE product_id = $3 AND reserved_quantity - $4 >= 0`,
    SQL_GET_PRODUCT_BY_PRODUCT_ID : `SELECT product_id, owner_id, product_name, price, description, quantity, reserved_quantity, created_at, updated_at FROM  pa_warehouse_service.warehouse  WHERE product_id = $1`,
    SQL_GET_PRODUCTS_BY_CATEGORY_ID :`SELECT 
    product_id, 
    product_name, 
    price, 
    description, 
    quantity, 
    reserved_quantity, 
    created_at, 
    updated_at 
FROM 
    pa_warehouse_service.warehouse
WHERE 
    (quantity - reserved_quantity) > 0
    AND (
        -- Если поисковый запрос NULL - игнорируем условия поиска
        $3::text IS NULL 
        OR
        -- Иначе ищем по всем полям и языкам
        (
            to_tsvector('russian', COALESCE(product_name, '')) @@ to_tsquery('russian', COALESCE($3::text, ''))
            OR
            to_tsvector('english', COALESCE(product_name, '')) @@ to_tsquery('english', COALESCE($3::text, ''))
            OR 
            to_tsvector('russian', COALESCE(description, '')) @@ to_tsquery('russian', COALESCE($3::text, ''))
            OR
            to_tsvector('english', COALESCE(description, '')) @@ to_tsquery('english', COALESCE($3::text, ''))
        )
    )
ORDER BY 
    created_at DESC
LIMIT $2
OFFSET ($1 - 1) * $2
`,
  SQL_GET_PRODUCTS_BY_CATEGORY_ID2 : `
SELECT 
    product_id, 
    product_name, 
    price, 
    description, 
    quantity, 
    reserved_quantity, 
    created_at, 
    updated_at 
FROM 
    pa_warehouse_service.warehouse 
WHERE 
    (quantity - reserved_quantity) > 0
    AND ( $4::int[] IS NULL  OR  categories && $4::int[] )
    AND ( $5::int[] IS NULL  OR  brands && $5::int[] )
    AND ( $6::int IS NULL  OR  price >= $6::int )
    AND ( $7::int IS NULL  OR  price <= $7::int )        
    AND (
        -- Если поисковый запрос NULL - игнорируем условия поиска
        $3::text IS NULL 
        OR
        -- Иначе ищем по всем полям и языкам
        (
            -- Преобразуем набор строк в массив и ищем совпадения в любом из элементов
            $3::text = ANY(STRING_TO_ARRAY(product_name, ' '))
            OR
            $3::text = ANY(STRING_TO_ARRAY(description, ' '))
            OR
            -- Полнотекстовый поиск по русскому и английскому
            to_tsvector('russian', COALESCE(product_name, '')) @@ to_tsquery('russian', COALESCE($3::text, ''))
            OR
            to_tsvector('english', COALESCE(product_name, '')) @@ to_tsquery('english', COALESCE($3::text, ''))
            OR 
            to_tsvector('russian', COALESCE(description, '')) @@ to_tsquery('russian', COALESCE($3::text, ''))
            OR
            to_tsvector('english', COALESCE(description, '')) @@ to_tsquery('english', COALESCE($3::text, ''))
        )
    )
ORDER BY 
    -- Сначала сортируем по релевантности поиска
    CASE WHEN $3::text IS NOT NULL THEN
        GREATEST(
            -- Вес совпадений по названию
            ts_rank(to_tsvector('russian', COALESCE(product_name, '')), to_tsquery('russian', COALESCE($3::text, ''))),
            ts_rank(to_tsvector('english', COALESCE(product_name, '')), to_tsquery('english', COALESCE($3::text, ''))),
            -- Вес совпадений по описанию (можно уменьшить коэффициент)
            0.5 * ts_rank(to_tsvector('russian', COALESCE(description, '')), to_tsquery('russian', COALESCE($3::text, ''))),
            0.5 * ts_rank(to_tsvector('english', COALESCE(description, '')), to_tsquery('english', COALESCE($3::text, '')))
        )
    ELSE 0 END DESC,
    -- Затем по дате создания
    created_at DESC
LIMIT $2
OFFSET ($1 - 1) * $2
`,
    SQL_GET_PRODUCTS_BY_CATEGORY_ID1 : `
    SELECT 
    product_id, 
    product_name, 
    price, 
    description, 
    quantity, 
    reserved_quantity, 
    created_at, 
    updated_at 
    FROM 
      pa_warehouse_service.warehouse
    WHERE 
      (quantity - reserved_quantity) > 0  -- Только товары с положительным остатком
      and ($3 = $3 and product_name like '%$3%' )         
    ORDER BY 
      created_at DESC
    LIMIT 
      $2
    OFFSET 
      ($1 - 1) * $2

    `,
SQL_GET_PRODUCTS_BY_CATEGORY_LIKE : `
SELECT 
    product_id, 
    product_name, 
    price, 
    description, 
    quantity, 
    reserved_quantity, 
    created_at, 
    updated_at 
FROM 
    pa_warehouse_service.warehouse
WHERE 
    (quantity - reserved_quantity) > 0
    AND ( $4::int IS NULL  OR  price >= $4::int )
    AND ( $5::int IS NULL  OR  price <= $5::int )                
    AND (
        -- Если поисковый запрос NULL - игнорируем условия поиска
        $3::text IS NULL 
        OR
        -- Иначе ищем по всем полям
        (
            -- Добавляем LIKE/ILIKE поиск
            product_name ILIKE '%' || $3::text || '%'
            OR description ILIKE '%' || $3::text || '%'
        )
    )
ORDER BY 
    -- Сначала сортируем по точным совпадениям с названием
    CASE WHEN product_name ILIKE $3::text THEN 0
         WHEN product_name ILIKE '%' || $3::text || '%' THEN 1
         WHEN description ILIKE $3::text THEN 2
         WHEN description ILIKE '%' || $3::text || '%' THEN 3
         ELSE 4 END,
    created_at DESC
LIMIT $2
OFFSET ($1 - 1) * $2
`,

    SQL_GET_PRODUCT_COUNT : `
    SELECT (w.quantity - w.reserved_quantity) as available_quantity FROM pa_warehouse_service.warehouse w WHERE w.product_id = $1`,  
    SQL_GET_BASKET_PRODUCTS_AVAILIABILITY : `
    SELECT wbi.product_id AS product_id, wbi.quantity AS items_in_basket, w.quantity AS items_in_warehouse,
     CASE WHEN w.quantity >= wbi.quantity THEN 1 ELSE 0 END AS availability
     FROM pa_warehouse_service.warehouse_basket_item wbi
     JOIN pa_warehouse_service.warehouse w ON wbi.product_id = w.product_id
     WHERE wbi.basket_id = $1 and wbi.order_id is null
    ORDER BY wbi.product_id;`,
  },
  BASKET : {  
    SQL_CREATE_BASKET : `INSERT INTO  pa_warehouse_service.warehouse_basket (user_id) VALUES ($1) ON CONFLICT DO NOTHING RETURNING id;`, // создать корзину
    SQL_FIND_BASKET_BY_ID : `SELECT * FROM  pa_warehouse_service.warehouse_basket WHERE id = $1 `,  // получить параметры корзины по id
    SQL_FIND_BASKET_BY_USER_ID : `SELECT * FROM  pa_warehouse_service.warehouse_basket WHERE user_id = $1 `, //  получить параметры корзины по userId
    SQL_FIND_BASKET_ITEM_BY_PRODUCT_ID : `SELECT * FROM  pa_warehouse_service.warehouse_basket_item WHERE  order_id is null and basket_id = $1 AND product_id = $2`,    
    SQL_UPDATE_BASKET_REMOVE_ITEM_BY_PRODUCT_ID : `UPDATE  pa_warehouse_service.warehouse_basket_item SET quantity = 0 WHERE order_id is null and basket_id = $1 AND product_id = $2`,
    SQL_INSERT_BASKET_QUANTITY_ITEM_BY_PRODUCT_ID : `INSERT INTO  pa_warehouse_service.warehouse_basket_item (quantity, basket_id, product_id ) VALUES ($1, $2, $3)`,
    SQL_UPDATE_BASKET_CHANGE_QUANTITY_ITEM_BY_PRODUCT_ID : `
    UPDATE  pa_warehouse_service.warehouse_basket_item 
    SET quantity = quantity + $1 
    WHERE order_id is null and basket_id = $2 AND product_id = $3 and quantity >= 0
    RETURNING quantity`,
    SQL_UPSERT_BASKET_QUANTITY : 
    `INSERT INTO pa_warehouse_service.warehouse_basket_item (quantity, basket_id, product_id)
    VALUES ($1, $2, $3)
    ON CONFLICT (basket_id, product_id, order_id)
    DO UPDATE 
    SET quantity = warehouse_basket_item.quantity + EXCLUDED.quantity
    WHERE warehouse_basket_item.order_id IS NULL
    RETURNING quantity;`,    
    SQL_ADD_BASKET_QUANTITY_ITEM_BY_PRODUCT_ID : `INSERT INTO  pa_warehouse_service.warehouse_basket_item (basket_id, product_id, quantity) VALUES ($1, $2, $3)`,
    SQL_GET_BASKET_ITEMS : `SELECT wbi.*, w.product_name, w.price, w.description FROM  pa_warehouse_service.warehouse_basket_item wbi
      LEFT JOIN  pa_warehouse_service.warehouse w on (w.product_id = wbi.product_id) 
      WHERE wbi.quantity > 0 and order_id is null and basket_id = $1 and wbi.deleted_at is null`,
    SQL_GET_BASKET_ORDER_ITEMS : `SELECT  wbi.product_id, wbi.quantity, w.product_name, w.price, w.description 
    FROM  pa_warehouse_service.warehouse_basket_item wbi
      LEFT JOIN  pa_warehouse_service.warehouse w on (w.product_id = wbi.product_id)  
      WHERE  wbi.quantity > 0 and wbi.order_id = $1 and wbi.basket_id = $2 and wbi.deleted_at is null`,
    SQL_ORDER_CREATE  : `UPDATE pa_warehouse_service.warehouse_basket_item SET order_id = $1 WHERE order_id is null and basket_id = $2`,
    GET_PRODUCT_COUNT : `SELECT SUM(quantity) as quantity from pa_warehouse_service.warehouse_basket_item 
    where basket_id=$1 and product_id=$2 and order_id is null and deleted_at is null`,
    SQL_GET_ORDER_DETAILS : `SELECT * FROM warehouse_basket_item 
    WHERE basket_id = $1 AND order_id = $2`,
    ORDER_DECLINE : `UPDATE pa_warehouse_service.warehouse_basket_item SET order_id = null 
    WHERE basket_id = $2 AND order_id = $1`,
    SQL_REMOVE_ITEM_BY_PRODUCT_ID_FROM_ORDER : `UPDATE pa_warehouse_service.warehouse_basket_item
     SET deleted_at = now() 
     WHERE product_id = $3 AND order_id = $2 and basket_id=$1`,
  }
};

const MESSAGES = {
   RU : {    
      INPUT_VALIDATION_ERROR: 'Ошибка проверки входных данных',
      PRODUCT_ID_REQUIRED: 'Ошибка проверки productId',
      PRODUCT_NOT_FOUND: 'Продукт не найден',
      PRODUCT_UNAVAILABLE : 'Товар закончился на складе',
      ERROR_FETCHING_MEDIA: 'Ошибка получения медиафалов для продукта',
      ERROR_FETCHING_PRODUCT: 'Ошибка получения продукта',
      ERROR_FETCHING_WAREHOUSE: 'Ошибка при получении информации о состоянии склада',
      RESERVE_ITEM_SUCCESS : 'Резервирование товара выполнено',
      RESERVE_ITEM_FAILED : 'Возникла ошибка при резервирование товара',
      RELEASE_ITEM_SUCCESS : 'Отмена резервирования товара выполнена',   
      RELEASE_ITEM_FAILED :  'Возникла ошибка при отмене резервирования товара',     
      ERROR_REMOVING_PRODUCT_FROM_BASKET : 'Ошибка удаления продукта из корзины',
      SQL_REMOVE_ITEM_BY_PRODUCT_ID_FROM_ORDER: 'Ошибка удаления продукта из заказа', 
   }
}

/* Экспорт */
module.exports = {
  SQL, MESSAGES
};
